{"content":"\n# Prerequisites\n\nI'm going to assume that:\n\n- You know typescript reasonably well\n- You have powertool and the std kit installed\n- You are on linux or MacOS\n- You are at least an intermediate level programmer. I'm not going to be explaining any of the basic stuff\n\n# What are we building?\n\nLet's build a kit that parses a bunch of markdown files into JSON for use in a static site generator. For example, lets say we have the filetree:\n\n```txt\ncontent/\n  docs/\n    getting-started/\n      index.mdx\n      installation.mdx\n      usage.mdx\n    building-kits/\n      index.mdx\n      using-action-files.mdx\n      bun/\n        index.mdx\n        api.mdx\n     ...\n  posts/\n    release-1.0.md\n    release-2.0.mdx\n```\n\nWe should output something that looks like:\n\n```txt\npublic/\n  genreated-content/\n    list.json\n    getting-started.json\n    getting-started>installation.json\n    getting-started>usage.json\n    building-kits.json\n    building-kits>using-action-files.json\n    building-kits>bun.json\n    building-kits>bun>api.json\n    posts>release-1.0.json\n    posts>release-2.0.json\n    ...\n```\n\nThe `list.json` file should be:\n\n```json\n[\n    {\n        \"route\": \"docs/getting-started\"\n        \"frontmatter\": {\n            \"title\": \"Getting Started\",\n            \"author\": \"Jonathan Deiss\",\n            \"weight\": 100\n        },\n        \"outline\": [\n            {\n                \"type\": \"h1\",\n                \"text\": \"My first header\"\n            },\n            {\n                \"type\": \"h2\",\n                \"text\": \"Another header\"\n            },\n            ...\n        ]\n    },\n    {\n        \"route\": \"docs/getting-started/installation\",\n        \"frontmatter\": \"...\"\n        \"outline\": \"...\"\n    },\n    {\n        \"route\": \"posts/release-1.0\",\n        \"frontmatter\": \"...\",\n        \"outline\": \"...\"\n    },\n    ...\n]\n```\n\nIt's useful for building something like a sidebar which needs to know about each route, but not the actual content.\n\nAll of the other files are the actual data on each route. It should look something like:\n\n```json\n{\n    \"frontmatter\": {\n        \"title\": \"Something\"\n        ...\n    },\n    \"outline\": [\n        ...\n    ],\n    \"content\": \"this is the raw content in text for the file\\n. It could be very long, which is why we split it into multiple files.\\n\"\n}\n```\n\nIt's basically the same as the entries for list.json, but also contains the content field for the actual raw content in each markdown file. It's the burden of the consumer of this tool to parse that content into HTML. At the end, I'll demo how to do that using Next.js and it's MDX renderer.\n\n### A note on frontmatter\n\nIf you're unfamiliar with frontmatter, it's a way to define metadata on a markdown file using YAML. Take the following markdown file as an example:\n\n```md\n---\ntitle: An example of frontmatter\nauthor: Someone Cool\ndate: 5/5/2125\n---\n\n# Rest of the article\n\nlorem ipsum\n```\n\nThe frontmatter for this in json would be:\n\n```json\n{\n  \"title\": \"An example of frontmatter\",\n  \"author\": \"Someone Cool\",\n  \"date\": \"5/5/2125\"\n}\n```\n\n# Creating the project\n\nTo create the project, we'll first create an empty repo. I prefer to do this with the github CLI, but you can do what you want. I'll call this repo \"Simple Content Layer\" (If you're wondering, I am writing this article while building the actual repo Simple Content Layer). Once inside the folder, I'll run `ptx pwrtool/std new-kit` to create the new kit, and open it in my editor.\n\n```bash\ngh repo create\ncd simple-content-layer\nptx pwrtool/std new-kit\nbun install\nnvim .\n```\n\nFor this tutorial, we won't be doing anything fancy with the `run.sh` script or `install.sh` script. They aren't executables by default though, so make sure to run:\n\n```bash\nchmod +x run.sh\nchmod +x install.sh\n```\n\nNow let's make sure that the default hello world is working. Run the command `ptx pwrtool/std test-run`. If you answer the first question with \"default\", you should see output that looks like:\n\n```txt\nRunning the test-run tool from pwrtool/std\nüîç Searching for local install.sh\nüìÇ Using kit directory: /home/firesquid/source/simple-content-layer\n‚úÖÔ∏è Found install.sh file\n\nüìú Running install script in /home/firesquid/source/simple-content-layer\nbun install v1.0.8 (2a405f69)\n\nChecked 4 installs across 5 packages (no changes) [1.00ms]\n‚úÖÔ∏è No errors found in install script!\nRun `ptx bench/test <tool>` to test your kit\n\nWhat tool do you want to run?\ndefault\n\nRunning default from bench/test:\nHello world!\nTool finished successfully.\n```\n\n# Getting our Inputs\n\n## Plan\n\nWe'll need two inputs from the user:\n\n1. Where are your markdown files?\n2. Where do you want the crap to go?\n\nTo get this, we'll ask in two different ways:\n\n1. If the user provided a CLI arg, we'll just go with that\n2. If no CLI arg was provided, check the config file\n3. If neither of those two work, we'll just throw an error\n\n### Why not ask a question if the first two fail?\n\nI'm building this under the assumption that it will be used in CI pipelines. Since you can't answer questions there, it's better to just throw an error. Questions are best used when the following conditions are true:\n\n1. A human will always be running the tool (questions are automatable but painful)\n2. The input is long or complex\n3. The input is part of a sequential chain\n\n## Code\n\nTo get these inputs, we'll use the following code for `index.ts`:\n\n```ts\nimport powertool from \"@pwrtool/kit\";\n\npowertool([\n  {\n    name: \"default\",\n    function: async (IO, CliArgs, Config) => {\n      const argsKeys = [\"input\", \"output\"];\n      const argValues = [];\n\n      for (const key of argsKeys) {\n        if (CliArgs.exists(key)) {\n          argValues.push(CliArgs.get(key));\n          continue;\n        }\n        if (Config.exists(key)) {\n          argValues.push(Config.get(key));\n          continue;\n        }\n\n        IO.error(`${key} could not be found in cli args or config`);\n        break;\n      }\n\n      const [input, output] = argValues;\n      IO.out(`input: ${input}`);\n      IO.out(`output: ${output}`);\n    },\n  },\n]);\n```\n\nNow let's test and see if it works. If I run `ptx pwrtool/std test-run input=hello output=world`, the output I get is:\n\n```txt\nintput: hello\noutput: world\n```\n\nIf I don't provide anything, I get the output:\n\n```txt\ninput could not be found in cli args or config\ninput: undefined\noutput: undefined\n```\n\nIf I create a `ptconfig.yaml` file in the cwd that looks like:\n\n```yaml\n---\ninput: hello\noutput: world\n```\n\nI can now get the \"correct\" output without providing anything\n\n# Parsing a markdown file\n\nAs a general rule, the code for each tool inside of `index.ts` should only do:\n\n1. parse the inputs\n2. run some function to do whatever thing you're doing\n3. give an output based on the result of #2\n\nIf the tool is very simple, you can just put the actual logic for it in the `index.ts` file, but for anything complex (anything greater than around 50 lines) it's recommended you create a `lib/` folder and write some tests.\n\n## Reading from the filesystem\n\nWe're going to use a technique called dependnecy injection to deal with reading and wring to the filesystem. To do this, create the `lib/filesystem.ts` file.\n\nIn this file, create the `Filesystem` interface:\n\n```ts\nexport interface Filesystem {\n  files: string[];\n  read(filepath: string): string | null;\n  exists(filepath: string): boolean;\n}\n```\n\nThere's no write function since we won't need it.\n\nWe'll then wrap the `fs` package using this interface and create a class called `LocalDirectory`:\n\n```ts\nexport class LocalDirectory implements Filesystem {\n  files: string[] = [];\n\n  constructor(directory: string) {\n    this.files = recursivelyReadDir(directory);\n  }\n\n  read(filepath: string): string | null {\n    if (fs.existsSync(filepath)) {\n      console.log(\"exists\");\n      return fs.readFileSync(filepath, \"utf8\");\n    } else {\n      return null;\n    }\n  }\n\n  exists(filepath: string): boolean {\n    return this.files.includes(filepath);\n  }\n}\n```\n\nYou'll also need a `recursivelyReadDir` function:\n\n```ts\nfunction recursivelyReadDir(directory: string): string[] {\n  const files = fs.readdirSync(directory);\n  const results: string[] = [];\n\n  for (const file of files) {\n    const filepath = `${directory}/${file}`;\n\n    if (fs.statSync(filepath).isDirectory()) {\n      results.push(...recursivelyReadDir(filepath));\n    } else {\n      results.push(filepath);\n    }\n  }\n\n  return results;\n}\n```\n\nNow that we can read from the filesystem, we can move on to creating a list of content files.\n\n## Creating ContentFiles\n\nFirst, create a file called `lib/parse.ts`. This file will be used for turning raw files into a type we can deal with and sort. We'll create the `ContentFile` type like so:\n\n```ts\nexport type ContentFile = {\n  path: string;\n  extension: string;\n  data: string;\n};\n```\n\nWe'll also need a `parseFilesInDirectory` function to turn a filesystem into an array of `ContentFile`s. I wrote some tests for this, but I won't bother including those here. Here's the code for `parseFilesInDirectory`:\n\n```ts\nexport function parseFilesInDirectory(\n  filesystem: Filesystem,\n  allowedExtensions = [\"md\", \"mdx\"],\n): ContentFile[] {\n  const files = filesystem.files;\n  const results: ContentFile[] = [];\n\n  for (const file of files) {\n    let path = file.replace(/^\\.\\//, \"\");\n\n    const pathParts = path.split(\".\");\n    const extension = pathParts.pop();\n    path = pathParts.join(\".\");\n\n    if (!extension || !allowedExtensions.includes(extension)) {\n      continue;\n    }\n    const data = filesystem.read(file);\n    if (data) {\n      results.push({\n        path: path,\n        extension: extension || \"\",\n        data,\n      });\n    }\n  }\n\n  return results;\n}\n```\n\n# Generating ContentRoutes\n\nNow we'll need the `ContentRoute` type. This should look like the JSON you saw earlier for each route file. Create a `lib/route.ts` file with the following code:\n\n```ts\nexport type ContentRoute = {\n  route: string;\n  content: string;\n  frontmatter: object;\n  outline: Header[];\n};\n```\n\nYou'll get an error with the `OutlineNode` type. We'll create that in a bit.\n\nNow it's time to actually create the `ContentRoutes` that we'll output in our json files. To do this we'll need to:\n\n1. Figure out the route based on the filepath (i.e. docs/index.md -> docs/)\n2. Get the Outline for a file\n3. Get the frontmatter for a file\n\n## Generating Outlines\n\nIn that same file, create the `OutlineNode` type:\n\n```ts\nexport type Header = {\n  text: string;\n  level: string;\n};\n```\n\nNow let's write an algorithm to find these headers!\n\nUse the following function:\n\n```ts\nexport function getHeaders(content: string): Header[] {\n  const headers: Header[] = [];\n  const lines = content.split(\"\\n\");\n\n  for (const line of lines) {\n    const match = line.match(/^(#+)\\s+(.*)$/);\n    if (match) {\n      const level = match[1].length;\n      const text = match[2];\n      headers.push({\n        text,\n        level,\n      });\n    }\n  }\n\n  return headers;\n}\n```\n\nGithub copilot autocompleted this one for me. No clue what the regex even does tbh.\n\n## Parsing Frontmatter\n\nParsing frontmatter is easy, we can just use the [gray matter](https://www.npmjs.com/package/gray-matter) library:\n\n```ts\nexport function splitFrontmatter(data: string): {\n  frontmatter: object;\n  content: string;\n} {\n  const result = matter(data);\n\n  return {\n    frontmatter: result.data,\n    content: result.content,\n  };\n}\n```\n\n## Figuring out the Route\n\nFiguring out the route is also not that difficult. Here's basically what we want:\n\n- docs/something.md -> docs/something\n- docs/index -> docs/\n- docs/another/coolthing -> docs/another/coolthing\n- docs/another/index -> docs/another\n\nWe really just need to check if there's an index at the end, and remove it if there is.\n\nNot my finest work, but it passes the tests:\n\n```ts\nexport function getRoute(filepath: string): string {\n  if (filepath.at(0) === \"/\") {\n    filepath = filepath.slice(0);\n  }\n\n  const len = filepath.length;\n  if (filepath.at(len - 1) === \"/\") {\n    filepath = filepath.substring(0, len - 1);\n  }\n\n  const split = filepath.split(\"/\");\n  if (split[split.length - 1] === \"index\") {\n    split.pop();\n  }\n\n  let route = split.join(\"/\");\n\n  if (route.at(0) !== \"/\") {\n    route = \"/\" + route;\n  }\n\n  return route;\n}\n```\n\n## Put it all together!\n\nNow that we have all the ingredients, we can put it together to make one very cool function:\n\n```ts\nexport function getContentRoutes(files: ContentFile[]): ContentRoute[] {\n  const routes: ContentRoute[] = [];\n  for (const file of files) {\n    const route: ContentRoute = {\n      route: \"\",\n      content: \"\",\n      outline: [],\n      frontmatter: {},\n    };\n\n    const { content, frontmatter } = splitFrontmatter(file.data);\n    route.frontmatter = frontmatter;\n    route.content = content;\n\n    route.route = getRoute(file.path);\n    route.extension = file.extension;\n    route.outline = getHeaders(content);\n\n    routes.push(route);\n  }\n\n  return routes;\n}\n```\n\n# Outputting the files\n\nNow we just need to create two functions to get the output files. I'll put them in `lib/output.ts`:\n\n```ts\nexport type OutputFile = {\n  content: string;\n  outline: Header[];\n  extension: string;\n  frontmatter: object;\n};\n\nexport function getOutputFiles(\n  routes: ContentRoute[],\n): Map<string, OutputFile> {\n  const outputFiles = new Map<string, OutputFile>();\n\n  for (const route of routes) {\n    const key = route.route.replace(\"/\", \">\") + \".json\";\n    outputFiles.set(key, {\n      content: route.content,\n      outline: route.outline,\n      extension: route.extension ?? \"md\",\n      frontmatter: route.frontmatter,\n    });\n  }\n\n  return outputFiles;\n}\n\ntype ListItem = {\n  route: string;\n  frontmatter: object;\n  outline: Header[];\n};\n\nexport type ListFile = ListItem[];\n\nexport function getListFile(routes: ContentRoute[]): ListFile {\n  const listFile: ListFile = [];\n  for (const route of routes) {\n    const listItem: ListItem = {\n      route: route.route,\n      frontmatter: route.frontmatter,\n      outline: route.outline,\n    };\n    listFile.push(listItem);\n  }\n\n  return listFile;\n}\n```\n\n# Wrapping it Up\n\nNow head back to your `index.ts` file to create the final output of the tool.\n","outline":[{"text":"Prerequisites","level":1},{"text":"What are we building?","level":1},{"text":"A note on frontmatter","level":3},{"text":"Rest of the article","level":1},{"text":"Creating the project","level":1},{"text":"Getting our Inputs","level":1},{"text":"Plan","level":2},{"text":"Why not ask a question if the first two fail?","level":3},{"text":"Code","level":2},{"text":"Parsing a markdown file","level":1},{"text":"Reading from the filesystem","level":2},{"text":"Creating ContentFiles","level":2},{"text":"Generating ContentRoutes","level":1},{"text":"Generating Outlines","level":2},{"text":"Parsing Frontmatter","level":2},{"text":"Figuring out the Route","level":2},{"text":"Put it all together!","level":2},{"text":"Outputting the files","level":1},{"text":"Wrapping it Up","level":1}],"extension":"md","frontmatter":{"title":"Docs Generator with Bun"}}